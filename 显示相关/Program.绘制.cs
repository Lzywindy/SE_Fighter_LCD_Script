using System;
using System.Diagnostics;
using VRage.Game.GUI.TextPanel;
using VRageMath;

namespace IngameScript
{
    public partial class Program
    {
        public static partial class 绘制
        {
            public static void 雷达告警(雪碧列表 图, My显示参数 数据, 边界框 绘区, Color 基色, Color 背景, float 线宽 = 1, bool 线框 = true, bool 裁剪 = true)
            {
                const float 占比 = 0.8f, 内圈 = 0.55f;
                float Δ值 = MathHelper.ToRadians(15f), F值 = MathHelper.ToRadians(360), 缩进线宽 = 线宽 * 2; ;
                边界框 方绘 = 边界框.创建_方形(绘区),
                    目区 = 方绘 * 占比 + 向量(0, (1 - 占比) * 0.5f * 方绘.尺寸.Y),
                    内区 = 目区 * 内圈, 最里层 = 内区 * 0.4f,
                    文本提示区 = 边界框.创建_中心_尺寸(方绘.中心 - 向量(0, 占比 * 0.5f * 方绘.尺寸.Y), 向量(4, 1) * 方绘.最小边长 * (1 - 占比) * 0.8f);
                线框和裁切(图, 方绘, 基色, 背景, 缩进线宽, 线框, 裁剪);
                图.框框(方图1, 文本提示区, 基色, 背景, 缩进线宽, 0);
                自适应文本(图, 文本提示区 * 0.8f, "敌跟踪", 基色);
                图.框框(圆图, 目区, 基色, 背景, 缩进线宽, 0);
                图.框框(圆图, 内区, 基色, 背景, 缩进线宽, 0);
                图.框框(圆图, 最里层, 基色, 背景, 缩进线宽, 0);
                /*
                 * 待做： 高速物体接近预测（留在MOD里面做）
                 */
                float 半径 = V最小值(目区.半尺寸);
                for (float 刻 = 0, k = 0; 刻 < F值; 刻 += Δ值, k += 1) { float 长度 = (k % 6 == 0) ? (1 - 内圈 * 0.4f) : (k % 3 == 0) ? 0.15f : 0.1f, 偏移 = (1 - 长度 * 0.5f); 图.图案(方图1, 目区.中心 + 半径 * 偏移 * 向量_从角度(刻), 向量(半径 * 长度, 线宽), 基色, 刻); }
                图.图案(圆图, 最里层 * 0.3f, 基色);
            }





            public static void 全信息屏幕(雪碧列表 图, My显示参数 数据, My物理包 物理包, Color 基色, float 线宽, ref 全信息边界分区 分区, float 屏幕比例, Action<string> Debug)
            {
                const float 临界换行比例 = (5.0f / 3.0f), 最大临界比 = 1.1f;
                TextAlignment 文本对齐 = (屏幕比例 < 临界换行比例) ? TextAlignment.CENTER : TextAlignment.LEFT;
                雷达正视(图, 物理包, 分区.框_正视, 线宽, 基色, 背景, 数据, true, true, false, true);
                地平线(图, 物理包, 分区.框_水平仪, 线宽, 基色, 背景);
                雷达平面(图, 分区.框_平面, 线宽, 基色, 背景, 数据);
                bool 不简化 = 屏幕比例 >= 临界换行比例 * 最大临界比 || 屏幕比例 < 临界换行比例;
                float 文 = 不简化 ? 1 : (屏幕比例 >= 临界换行比例) ? 0.6f : 1f;
                string 滚转名 = 不简化 ? "滚转" : "R", 俯仰名 = 不简化 ? "俯仰" : "P", 速度名 = 不简化 ? "速度" : "SPD", 分隔1 = (屏幕比例 < 临界换行比例) ? "\n" : " ", 分隔2 = (屏幕比例 < 临界换行比例) ? "\n" : "->";
                文本参数(图, 分区.框_速度, $"{速度名}{分隔1}{速率转文本(物理包.飞船速度, 1)}", 文本对齐, 线宽, 基色, 背景, 文);
                文本参数(图, 分区.框_滚转, $"{滚转名}{分隔1}{Math.Round(MathHelper.ToDegrees(-物理包.滚转角))}", 文本对齐, 线宽, 基色, 背景, 文);
                文本参数(图, 分区.框_俯仰, $"{俯仰名}{分隔1}{Math.Round(MathHelper.ToDegrees(物理包.俯仰角))}", 文本对齐, 线宽, 基色, 背景, 文);
                文本参数(图, 分区.框_水平范围, $"范围{分隔2}{距离转文本(数据.显示范围)}", 文本对齐, 线宽, 基色, 背景, 文, 屏幕比例 > 4.2f);
                文本参数(图, 分区.框_水平模式, $"模式{分隔2}{数据.显示逻辑}", 文本对齐, 线宽, 基色, 背景, 文, 屏幕比例 > 4.2f);
                文本参数(图, 分区.框_锁定参数, $"锁定{分隔2}{距离转文本(数据.锁定范围)}", 文本对齐, 线宽, 基色, 背景, 文, 屏幕比例 > 4.2f);
                文本参数(图, 分区.框_锁定模式, $"模式{分隔2}{数据.锁定逻辑}", 文本对齐, 线宽, 基色, 背景, 文, 屏幕比例 > 4.2f);
                文本参数(图, 分区.框_武器类型, $"武器{分隔2}{数据.当前武器}", 文本对齐, 线宽, 基色, 背景, 文, 屏幕比例 > 4.2f);
                文本参数(图, 分区.框_武器模式, $"模式{分隔2}{数据.武器逻辑}", 文本对齐, 线宽, 基色, 背景, 文, 屏幕比例 > 4.2f);
                设备百分条(图, 分区.框_护盾, "护盾", 数据.护盾储能百分比, 线宽, 基色, 背景, 文);
                设备百分条(图, 分区.框_曲速, "曲速", 数据.电力储能百分比, 线宽, 基色, 背景, 文);
                设备百分条(图, 分区.框_电能, "电能", 数据.曲速储能百分比, 线宽, 基色, 背景, 文);
                设备百分条(图, 分区.框_燃料, "燃料", 数据.氢气储量百分比, 线宽, 基色, 背景, 文);
                设备百分条(图, 分区.框_武器1, 数据.武器1名称, 数据.武器1参数_百分比, 线宽, 基色, 背景, 文);
                设备百分条(图, 分区.框_武器2, 数据.武器2名称, 数据.武器2参数_百分比, 线宽, 基色, 背景, 文);
                设备百分条(图, 分区.框_武器3, 数据.武器3名称, 数据.武器3参数_百分比, 线宽, 基色, 背景, 文);
                设备百分条(图, 分区.框_武器4, 数据.武器4名称, 数据.武器4参数_百分比, 线宽, 基色, 背景, 文);
                if (数据.武器5类型 == "导弹")
                    方块导弹区域(图, 分区.框_武器5, 数据.武器5数量, 线宽, 基色, 背景, Debug);
                else
                    方块无人机区域(图, 分区.框_武器5, 数据.武器5数量, 线宽, 基色, 背景);
            }
            public static void 雷达平面(雪碧列表 图, 边界框 绘区, float 线宽, Color 基色, Color 背景, My显示参数 数据, bool 线框 = true, bool 裁剪 = true)
            {
                const int 刻度数 = 40;
                const float 间隔角度 = 360f / 刻度数, 内圈 = 0.55f;
                边界框 方绘 = 边界框.创建_方形(绘区), 目标区 = 方绘 * 雷达显示占比, 内圈_目标区 = 目标区 * 内圈;
                float 缩进线宽 = 线宽 * 2, 半径 = 目标区.最小边长 * 0.5f, _缩放 = 目标区.最小边长 / 参考尺寸;
                数据.显示范围 = Math.Max(数据.显示范围, 1000);
                Vector2 _线宽 = 向量(线宽 * 2), 角度坐标 = Vector2.Zero, 角度坐标_半径 = Vector2.Zero, 字体偏移 = 向量(0, 字体大小 * 字体尺寸 * 0.5f);
                线框和裁切(图, 方绘, 基色, 背景, 缩进线宽, 线框, 裁剪);
                图.框框(圆图, 目标区, 基色, 背景, 缩进线宽, 0);
                图.框框(圆图, 内圈_目标区, 基色, 背景, 缩进线宽, 0);
                for (int 序号 = 0; 序号 < 刻度数; 序号++)
                {
                    float 角度 = MathHelper.ToRadians(序号 * 间隔角度), 显示刻度 = 角度循环转为360度(序号 * 间隔角度 + 90), 线长 = (序号 % 5 == 0) ? 0.1f : 0.05f, 线中心 = (1 - 线长 * 0.5f);
                    if (显示刻度 == 315 || 显示刻度 == 45) { 线长 = 1; 线中心 = 0.5f; }
                    角度坐标 = 向量_从角度(角度);
                    角度坐标_半径 = 角度坐标 * 半径;
                    图.图案(方图1, 目标区.中心 + 角度坐标_半径 * 线中心, 向量(线长 * 半径, 线宽), 基色, 角度);
                    if (序号 % 5 == 0)
                        图.文本($"{显示刻度}", 目标区.中心 + 角度坐标_半径 * 0.8f - 字体偏移, Color.White, 字体, TextAlignment.CENTER, _缩放);
                }
                平面目标(图, 数据, 目标区, 半径, 线宽);
                图.图案(三角图, 目标区.中心, 目标区.尺寸 * 0.05f, 基色);
            }
            public static void 雷达正视(雪碧列表 图, My物理包 物理包, 边界框 绘区, float 线宽, Color 基色, Color 背景, My显示参数 数据, bool 线框 = true, bool 裁剪 = true, bool 战斗机驾驶舱 = false, bool 单独 = false)
            {
                const float 提示偏移 = 0.02f;
                float 缩进线宽 = 线宽 * 2;
                边界框 方绘 = 边界框.创建_方形(绘区), 目标区 = 方绘 * 雷达显示占比, 文本边框区 = 边界框.创建(方绘.X0 + 方绘.最小边长 * 提示偏移, 方绘.X0 + 方绘.最小边长 * 0.25f, 方绘.Y0 + 方绘.最小边长 * 提示偏移, 方绘.Y0 + 方绘.最小边长 * 0.12f);
                线框和裁切(图, 方绘, 基色, 背景, 缩进线宽, 线框, 裁剪);
                if (战斗机驾驶舱) 文本边框区 += 向量(方绘.最小边长 * 0.125f, 0);
                float 半径 = 目标区.最小边长 * 0.5f;
                if (单独)
                    绘制瞄准(图, 数据, 基色, 背景, 方绘, 目标区, 线宽);
                else
                    角度线(图, 物理包, 目标区, 基色, 线宽, false, true, (图图) => { 绘制瞄准(图图, 数据, 基色, 背景, 方绘, 目标区, 线宽); });
                正面目标(图, 数据, 目标区, 半径, 线宽, My目标框种类.ACE7特殊锁);
                图.框框(方图1, 文本边框区, 基色, 背景, 缩进线宽, 0);
                float 文本实际大小 = 字体大小 * (文本边框区.最小边长 / 字体尺寸);
                图.文本($"{数据.武器逻辑}", 文本边框区.中心 + 向量(0, -文本实际大小 * 字体尺寸 * 0.5f), Color.White, 字体, TextAlignment.CENTER, 文本实际大小);
            }

            static void 绘制瞄准(雪碧列表 图, My显示参数 数据, Color 基色, Color 背景, 边界框 方绘, 边界框 目标区, float 线宽)
            {
                if (数据.武器逻辑 == "制导")
                {
                    图.框框(空心圆图, 目标区 * 锁定框比例, 基色, 背景, 线宽 * 2, 0);
                }
                else
                {
                    float 高度 = 目标区.尺寸.Y * 0.15f, 侧向扩展 = 0.2f, 左侧X = 方绘.中心.X - 目标区.尺寸.X * 侧向扩展, 右侧X = 方绘.中心.X + 目标区.尺寸.X * 侧向扩展, 根号2 = (float)Math.Sqrt(2), 高度_半 = 高度 * 0.5f, 投影 = 高度 * 0.4f, 投影_半 = 投影 * 0.5f, 斜长 = 根号2 * 投影;
                    图.十字(方绘 * 侧向扩展, 基色, 线宽, 0, 0.14f);
                    图.图案(方图1, 向量(左侧X, 方绘.中心.Y), 向量(线宽, 高度), 基色);
                    图.图案(方图1, 向量(右侧X, 方绘.中心.Y), 向量(线宽, 高度), 基色);
                    图.图案(方图1, 向量(左侧X + 投影_半, 方绘.中心.Y - 高度_半 - 投影_半), 向量(线宽, 斜长), 基色, 旋转: MathHelper.PiOver4);
                    图.图案(方图1, 向量(左侧X + 投影_半, 方绘.中心.Y + 高度_半 + 投影_半), 向量(线宽, 斜长), 基色, 旋转: -MathHelper.PiOver4);
                    图.图案(方图1, 向量(右侧X - 投影_半, 方绘.中心.Y - 高度_半 - 投影_半), 向量(线宽, 斜长), 基色, 旋转: -MathHelper.PiOver4);
                    图.图案(方图1, 向量(右侧X - 投影_半, 方绘.中心.Y + 高度_半 + 投影_半), 向量(线宽, 斜长), 基色, 旋转: MathHelper.PiOver4);
                }
            }

            public static void 雷达3D平面(雪碧列表 图, 边界框 绘区, float 线宽, Color 基色, Color 背景, My显示参数 数据, bool 线框 = true, bool 裁剪 = true, bool ED = false, bool 战斗机 = false)
            {
                float 字体大小 = 1, 提示偏移 = 0.02f;
                float 缩进线宽 = 线宽 * 2;
                Vector2 字体偏移 = 向量(0, 字体大小 * 字体尺寸 * 0.5f), 目标区_平面_缩放 = 向量(1, 立体雷达视角_值.X) * 0.9f;
                边界框 方绘 = 边界框.创建_方形(绘区), 目标区 = 方绘 * 雷达显示占比, 目标区_平面 = 目标区 * 目标区_平面_缩放, 文本边框区 = 边界框.创建(方绘.X0 + 方绘.最小边长 * 提示偏移, 方绘.X0 + 方绘.最小边长 * 0.25f, 方绘.Y0 + 方绘.最小边长 * 提示偏移, 方绘.Y0 + 方绘.最小边长 * 0.12f);
                float 文本实际大小 = 字体大小 * (文本边框区.最小边长 / 字体尺寸) * 0.6f, 半径 = 目标区.最小边长 * 0.5f, _缩放 = 目标区_平面.最大边长 / 参考尺寸;
                if (战斗机) 文本边框区 += 向量(方绘.最小边长 * 0.125f, 0);
                线框和裁切(图, 方绘, 基色, 背景, 缩进线宽, 线框, 裁剪);
                立体雷达背景(图, 目标区_平面, 缩进线宽, 基色, 背景, ED);
                立体目标(图, 数据, 目标区, 目标区_平面, 目标区_平面_缩放, 半径, 线宽);
                图.图案(三角图, 目标区_平面 * 0.05f, 基色);
                图.方框(文本边框区, 基色, 背景, 缩进线宽, 0);
                图.文本($"{距离转文本(数据.显示范围, 1)}", 文本边框区.中心 + 向量(0, -文本实际大小 * 字体尺寸 * 0.5f), Color.White, 字体, TextAlignment.CENTER, 文本实际大小);
            }
            public static void 锁定框(雪碧列表 图, Vector2 中心, Vector2 尺寸, Color 色, float 线宽, My目标框种类 种类, Vector2? 缩放 = null)
            {
                if (种类 == My目标框种类.无) return;
                const float 锁 = 1.0f / MathHelper.Sqrt2, 比_特殊 = 1f / 3f;
                边界框 框 = 边界框.创建_中心_尺寸(中心, 尺寸 * (缩放 ?? Vector2.One));
                Vector2 半尺寸 = 框.半尺寸, 一四 = 半尺寸 * 0.5f, 一八 = 一四 * 0.5f, 一三 = 尺寸 / 3f, 一六 = 一三 * 0.5f, 十二一 = 一六 * 0.5f;
                if (种类 == My目标框种类.ACE7普通框 || 种类 == My目标框种类.ACE7常规锁 || 种类 == My目标框种类.ACE7特殊锁)
                {
                    图.方框(框, 色, null, 线宽, 0);
                    if (种类 == My目标框种类.ACE7常规锁) 图.方框(框 * 锁, 色, null, 线宽, PIO4);
                    else if (种类 == My目标框种类.ACE7特殊锁) { 图.十字(框, 色, 线宽, 0, 比_特殊); 图.方框(框 * 比_特殊 * 锁, 色, null, 线宽, PIO4); }

                }
                else if (种类 == My目标框种类.镂空框)
                {
                    图.边角框(框, 色, null, 线宽, 0, 0.5f);
                }
            }
            public static void 地平线(雪碧列表 图, My物理包 物理包, 边界框 绘区, float 线宽, Color 基色, Color 背景, bool 线框 = true, bool 裁剪 = true)
            {
                const float 显示区域占比 = 1;// 0.8f;
                边界框 目标区 = 绘区 * 显示区域占比;
                float 尺寸 = 目标区.最小边长, _缩放 = 尺寸 / 参考尺寸, 半径 = 尺寸 * 0.5f, 缩进线宽 = 线宽 * 2;
                Vector2 位置 = 目标区.中心, _角度梯子大小 = 向量(尺寸 * 0.6f, 尺寸 * 0.06f), _角度梯子偏移 = 向量(0f, _角度梯子大小.Y), _内部大小 = 向量(1.2f, 1f);
                线框和裁切(图, 绘区, 基色, 背景, 缩进线宽, 线框, 裁剪);
                float 重力大小 = 物理包.重力大小, 速度大小 = 物理包.飞船速度;
                Vector3 重力矢量 = 物理包.重力矢量, 速度变化 = 物理包.Δ线速度 * 6f, 线速度矢量 = 物理包.线速度;
                if (MathHelper.IsZero(重力大小, 1e-2f) && 物理包.星球位置.HasValue) { 重力矢量 = 方向(物理包.星球位置.Value - 物理包.飞船_位置); 重力大小 = 1; }
                MatrixD 变换矩阵 = 物理包.控制器_世界矩阵;
                double 地表距离 = 物理包.地面高度 ?? double.MaxValue;
                float _屏幕框区 = (float)_内部大小.Length();
                角度线(图, 物理包, 目标区, 基色, 线宽, false, false);
            }
            static void 方块导弹区域(雪碧列表 图, 边界框 绘区, int 个数, float 线宽, Color 基色, Color 背景, Action<string> Debug)
            {
                图.裁剪(绘区);
                图.方框(绘区, 基色, 背景, 线宽, 0);
                边界框 目标区 = 边界框.缩进(绘区, 绘区.最小边长 * 内部距离);
                阵列参数 阵列 = new 阵列参数(目标区, 目标区.尺寸 * 向量(0.1f, 1f));
                阵列.得到行列和大小(个数, (索引, 框框) => { 方块导弹(图, 框框 * 0.8f, 线宽, 基色); });
            }
            static void 方块导弹(雪碧列表 图, 边界框 边框, float 线宽, Color 基色)
            {
                Vector2 _线宽 = 向量(线宽 * 2);
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, 0.23f), 边框.尺寸 * 向量(0.9f, 0.2f), Color.White);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(0, 0.4f), 边框.尺寸 * 向量(0.9f, 0.15f), Color.White);
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, -0.22f), 边框.尺寸 * 向量(0.75f, 0.2f), Color.White);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(0, -0.05f), 边框.尺寸 * 向量(0.75f, 0.15f), Color.White);
                图.图案(圆图, 边框.中心 - 边框.尺寸 * 向量(0, 0.3f), 边框.尺寸 * 向量(0.3f, 0.4f), Color.White);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(0, 0.1f), 边框.尺寸 * 向量(0.3f, 0.8f), Color.White);
                图.图案(圆图, 边框.中心 - 边框.尺寸 * 向量(0, 0.3f), 边框.尺寸 * 向量(0.3f, 0.4f) - _线宽, 基色);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(0, 0.1f), 边框.尺寸 * 向量(0.3f, 0.8f) - _线宽, 基色);
            }
            static void 方块无人机区域(雪碧列表 图, 边界框 绘区, int 个数, float 线宽, Color 基色, Color 背景)
            {
                图.裁剪(绘区);
                图.方框(绘区, 基色, 背景, 线宽, 0);
                边界框 目标区 = 边界框.缩进(绘区, 绘区.最小边长 * 内部距离);
                阵列参数 阵列 = new 阵列参数(目标区, 目标区.尺寸 * 向量(0.3f, 1f));
                阵列.得到行列和大小(个数, (索引, 框框) => { 方块无人机(图, 框框 * 0.8f, 线宽, 基色); });
            }
            static void 方块无人机(雪碧列表 图, 边界框 边框, float 线宽, Color 基色)
            {
                Vector2 _线宽 = 向量(线宽 * 2);
                const float ThOf = 0.35f, ThOfX = 0.06f;
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, 0.23f), 边框.尺寸 * 向量(0.9f, 0.3f), Color.White);
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, 0.4f), 边框.尺寸 * 向量(0.9f, 0.05f), Color.White, MathHelper.Pi);
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, 0.1f), 边框.尺寸 * 向量(0.55f, 0.5f), Color.White);
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, -0.1f), 边框.尺寸 * 向量(0.45f, 0.2f), Color.White);
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, -0.25f), 边框.尺寸 * 向量(0.1f, 0.2f), Color.White);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(0, 0.1f), 边框.尺寸 * 向量(0.1f, 0.5f), Color.White);
                图.图案(三角图, 边框.中心 + 边框.尺寸 * 向量(0, -0.25f), 边框.尺寸 * 向量(0.1f, 0.2f) - _线宽, 基色);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(0, 0.1f), 边框.尺寸 * 向量(0.1f, 0.5f) - _线宽, 基色);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(-ThOfX, ThOf), 边框.尺寸 * 向量(0.1f, 0.2f), Color.White);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(ThOfX, ThOf), 边框.尺寸 * 向量(0.1f, 0.2f), Color.White);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(-ThOfX, ThOf), 边框.尺寸 * 向量(0.1f, 0.2f) - _线宽, 基色);
                图.图案(方图1, 边框.中心 + 边框.尺寸 * 向量(ThOfX, ThOf), 边框.尺寸 * 向量(0.1f, 0.2f) - _线宽, 基色);
            }
        }

        public static partial class 绘制
        {
            static void 线框和裁切(雪碧列表 图, 边界框 绘区, Color 基色, Color 背景, float 线宽, bool 线框, bool 裁剪)
            {
                if (裁剪 || 线框)
                    图.裁剪(绘区);
                if (线框)
                    图.方框(绘区, 基色, 背景, 线宽, 0);
            }
            static void 平面目标(雪碧列表 图, My显示参数 数据, 边界框 绘区, float 半径, float 线宽)
            {
                Vector2 尺寸 = 绘区.尺寸 * 0.05f, 半尺寸 = 尺寸 * 0.5f;
                foreach (var 目标 in 数据.目标绘制)
                {
                    Vector2 偏移比 = 目标.顶视坐标 / 数据.显示范围, 偏移 = 偏移比 * 半径, 中心 = 绘区.中心 + 偏移, 偏移半 = 偏移 * 0.5f;
                    if (偏移比.LengthSquared() >= 1)
                        continue;
                    Color 色 = 派系颜色(目标);
                    if (数据.锁定列表.Contains(目标.实体编号))
                    {
                        图.图案(三角图, 中心 - 偏移半, 向量(V最小值(尺寸), 偏移.Length()), 透明RGB(色, 0.25f), 角度计算(偏移) - MathHelper.PiOver2);
                        锁定框(图, 中心, 尺寸, Color.OrangeRed, 线宽, My目标框种类.镂空框, 向量(1.2f));
                    }
                    图.图案(圆图, 中心, 尺寸, 色, 目标.顶视朝向);
                }
            }
            static void 正面目标(雪碧列表 图, My显示参数 数据, 边界框 绘区, float 半径, float 线宽, My目标框种类 锁定 = My目标框种类.ACE7常规锁)
            {
                foreach (var 目标 in 数据.目标绘制)
                {
                    if (!目标.正面坐标.HasValue)
                        continue;
                    Vector2 缩放 = 目标.正面坐标.Value / 雷达视场角度_弧度;
                    缩放.Y = -缩放.Y;
                    if (缩放.X >= 1 || 缩放.X <= -1 || 缩放.Y >= 1 || 缩放.Y <= -1)
                        continue;
                    Color 色 = 派系颜色(目标);
                    if (数据.锁定列表.Contains(目标.实体编号))
                        锁定框(图, 绘区.中心 + 缩放 * 半径, 绘区.尺寸 * 0.1f, 色, 线宽, 锁定);
                    else
                        锁定框(图, 绘区.中心 + 缩放 * 半径, 绘区.尺寸 * 0.1f, 色, 线宽, My目标框种类.ACE7普通框);
                }
            }
            static void 立体目标(雪碧列表 图, My显示参数 数据, 边界框 区, 边界框 区_平面, Vector2 区_平面_缩放, float 半径, float 线宽)
            {
                Vector2 尺寸 = 区.尺寸 * 0.05f, 绘制 = 尺寸 * 区_平面_缩放;
                foreach (var 目标 in 数据.目标绘制)
                {
                    Vector2 显示位置 = 向量(目标.本地坐标.X, Vector2.Dot(向量(目标.本地坐标.Z, -目标.本地坐标.Y), 立体雷达视角_值)) / 数据.显示范围, 投影位置 = 向量(目标.本地坐标.X, 目标.本地坐标.Z * 立体雷达视角_值.X) / 数据.显示范围;
                    if ((投影位置.X * 投影位置.X) / (区_平面.a * 区_平面.a) + (投影位置.Y * 投影位置.Y) / (区_平面.b * 区_平面.b) >= 1)
                        continue;
                    Color 色 = 派系颜色(目标), 投色 = 缩放RGB(色, 0.5f), 线色 = 缩放RGB(投色, 0.5f), 下色 = 缩放RGB(投色, 0.8f);
                    Vector2 投影中心 = 区.中心 + 投影位置 * 半径, 偏移 = 显示位置 * 半径, 中心 = 区.中心 + 偏移, 偏移半 = 偏移 * 0.5f;
                    显示位置.Y = MathHelper.Clamp(显示位置.Y, -1, 1);
                    图.图案(方图1, 向量(投影中心.X, (投影中心.Y + 中心.Y) * 0.5f), 向量(Math.Max(区.最小边长 * 0.01f, 1), Math.Abs(投影中心.Y - 中心.Y)), 线色);
                    图.图案(圆图, 投影中心, 区.尺寸 * 0.02f * 区_平面_缩放, 投色, 目标.顶视朝向);
                    if (数据.锁定列表.Contains(目标.实体编号))
                    {
                        图.图案(三角图, 中心 - 偏移半, 向量(V最小值(绘制), 偏移.Length()), 透明RGB(色, 0.25f), 角度计算(偏移) - MathHelper.PiOver2);
                        锁定框(图, 中心, 尺寸, Color.OrangeRed, 线宽, My目标框种类.镂空框, 向量(1.2f));
                    }
                    图.图案(圆图, 中心, 绘制, (目标.本地坐标.Y > 0) ? 色 : 下色, 目标.顶视朝向);
                }
            }
            static void 立体雷达背景(雪碧列表 图, 边界框 绘区, float 线宽, Color 基色, Color 背景, bool ED = false)
            {
                雪碧列表 组 = new 雪碧列表();
                int 迭代 = 3, 数量 = 0;
                float 开始 = 0.34f, 缩放 = 0, _缩放 = 绘区.最大边长 / 参考尺寸;
                if (ED)
                {
                    while (缩放 < 1)
                    {
                        float k值 = (float)Math.Log(数量 + 1) * 0.3f;
                        缩放 = MathHelper.Clamp(开始 + k值, 0, 1);
                        Color _前景 = 缩放RGB(基色, 缩放), _背景 = 缩放RGB(背景, 缩放);
                        数量++;
                        组.框框_逆(圆图, 绘区 * 缩放, _前景, _背景, 线宽, 0);
                    }
                }
                else
                {
                    var 变化量 = 1.0f / Math.Max(迭代, 1);
                    开始 = 变化量;
                    while (缩放 < 1)
                    {
                        缩放 = MathHelper.Clamp(开始 + 数量 * 变化量, 0, 1);
                        数量++;
                        组.框框_逆(圆图, 绘区 * 缩放, 基色, 背景, 线宽, 0);
                    }

                }
                组.Reverse();
                图.AddRange(组);
                if (!ED)
                {
                    for (int 序号 = 0; 序号 < 4; 序号++)
                    {
                        Vector2 角坐 = 向量_从角度(MathHelper.ToRadians(序号 * 45)), 向 = 角坐 * 绘区.半尺寸, 向字 = (绘区.半尺寸 + 向量(字体尺寸 * _缩放)) * 角坐, 线 = 向量(向.Length() * 2, 线宽 * 0.5f);
                        float 角度 = 角度计算(向);
                        图.图案(方图1, 绘区.中心, 线, 基色, 角度);
                        图.文本($"{角度循环转为360度(序号 * 45 + 90)}", 绘区.中心 + 向字, Color.White, "White", TextAlignment.CENTER, _缩放);
                        图.文本($"{角度循环转为360度(序号 * 45 + 270)}", 绘区.中心 - 向字, Color.White, "White", TextAlignment.CENTER, _缩放);
                    }
                }
            }
            static void 角度线(雪碧列表 图, My物理包 物理, 边界框 绘区, Color 基色, float 线宽, bool 有背景 = false, bool 有缩放 = true, Action<雪碧列表> 附加 = null)
            {
                const TextAlignment 对齐 = TextAlignment.CENTER;
                if (有背景) 基色 = Color.White;
                float 重力 = 物理.重力大小, 速率 = 物理.飞船速度;
                MatrixD 矩阵 = 物理.控制器_世界矩阵;
                Vector3 G = 物理.重力矢量, ΔV = 物理.Δ线速度 * 6f, V = 物理.线速度;
                边界框 水平绘区 = 边界框.创建_方形(绘区) * (有缩放 ? 0.4f : 0.8f);
                float 内圈 = 0.6f, 大小 = 1.5f, 尺寸 = 水平绘区.最小边长, _缩放 = 尺寸 / 参考尺寸, 半径 = 尺寸 * 0.5f;
                Vector2 位置 = 水平绘区.中心, _大小 = 向量(尺寸 * 0.6f, 尺寸 * 0.06f), _偏移 = 向量(0f, _大小.Y), _内部大小 = 向量(1.2f, 1f);
                double 地表距离 = 物理.地面高度 ?? double.MaxValue;
                if (物理.有星球 || !MathHelper.IsZero(重力, 1e-2f))
                {
                    double 滚 = 置零(物理.滚转角), 俯 = 置零(物理.俯仰角);
                    float 偏移百分比 = (float)俯 / 视场半角度, _高度 = 尺寸 / 刻度总数量, 偏移量 = 偏移百分比 * 半径, 左右 = _大小.X * 内圈;
                    int 角度符号 = Math.Sign(俯), 中间步 = (int)(俯 / 步进角度_弧度);
                    Vector2 _指向 = 向量_从角度(滚 + PIO2), _滚转 = 向量_从角度(滚) * _大小.X * 内圈, _尺寸 = 水平绘区.尺寸 * 9;
                    if (有背景)
                    {
                        图.图案(方图1, 位置 + _指向 * (偏移量 - _尺寸.Y * 0.5f), _尺寸, 水平仪上部分, (float)滚);
                        图.图案(方图1, 位置 + _指向 * (偏移量 + _尺寸.Y * 0.5f), _尺寸, 水平仪下部分, (float)滚);
                    }
                    for (int i = 中间步 - 俯仰角数量 / 2; i <= 中间步 + 俯仰角数量 / 2; i++)
                    {
                        float 刻度线偏移 = 偏移量 - i * _高度;
                        Vector2 偏移 = _指向 * 刻度线偏移, _中心 = 位置 + 偏移;

                        float 当前角 = i * 步进角度, 倍乘 = (当前角 % 5 == 0) ? 1f : 0.6f;
                        图.图案(((i < 0f) ? "AH_GravityHudNegativeDegrees" : "AH_GravityHudPositiveDegrees"), _中心, _大小 * 向量(倍乘, 1), 基色, (float)滚);
                        if (当前角 > 90) 当前角 = 180 - 当前角; else if (当前角 < -90) 当前角 = -180 - 当前角;
                        if (当前角 % 5 == 0)
                        {
                            string 文本 = 当前角.ToString();
                            图.文本(文本, _中心 - _滚转 - _偏移, 基色, 字体, 对齐, 大小 * _缩放);
                            图.文本(文本, _中心 + _滚转 - _偏移, 基色, 字体, 对齐, 大小 * _缩放);
                        }
                    }
                    if (G.Dot(物理.线速度) > 0 && 地表距离 < 速率 * 3)
                    {
                        图.图案("AH_PullUp", 绘区.中心, _缩放 * 向量(150f, 180f), 基色, (float)物理.滚转角);
                        图.文本("拉高", 位置 + 向量(0, 尺寸 * 0.1f), 基色, 字体, 对齐, 大小 * _缩放);
                    }
                }
                if (有缩放)
                {
                    float 高差 = (绘区.b - 水平绘区.b) * 0.4f, 高差_ = 高差 * 0.8f, 水差 = (绘区.a - 水平绘区.a) * 0.4f, 水差_ = 水差 * 0.8f, 水差__ = 水差 * 0.9f, NX = (绘区.b - 高差_ * 2) / 3, NX_H = NX * 0.12f, NX_HO = NX_H * 2;
                    图.图案(方图1, 边界框.创建(绘区.X0, 绘区.XM, 绘区.YM - 高差, 绘区.YM), 背景, 0);
                    图.图案(方图1, 边界框.创建(绘区.X0, 绘区.XM, 绘区.Y0, 绘区.Y0 + 高差), 背景, 0);
                    图.图案(方图1, 边界框.创建(绘区.XM - 水差, 绘区.XM, 绘区.Y0, 绘区.YM), 背景, 0);
                    图.图案(方图1, 边界框.创建(绘区.X0, 绘区.X0 + 水差, 绘区.Y0, 绘区.YM), 背景, 0);
                    附加?.Invoke(图);
                    图.图案(方图1, 边界框.创建(绘区.X0 + 水差_ - 线宽, 绘区.X0 + 水差_, 绘区.Y0 + 高差_, 绘区.YM - 高差_), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.XM - 水差_, 绘区.XM - 水差_ + 线宽, 绘区.Y0 + 高差_, 绘区.YM - 高差_), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.X0 + 水差_, 绘区.X0 + 水差, 绘区.Y0 + 高差_ - 线宽, 绘区.Y0 + 高差_), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.XM - 水差, 绘区.XM - 水差_, 绘区.Y0 + 高差_ - 线宽, 绘区.Y0 + 高差_), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.X0 + 水差_, 绘区.X0 + 水差, 绘区.YM - 高差_ - 线宽, 绘区.YM - 高差_), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.XM - 水差, 绘区.XM - 水差_, 绘区.YM - 高差_ - 线宽, 绘区.YM - 高差_), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.X0 + 水差_, 绘区.X0 + 水差__, 绘区.Y0 + 高差_ - 线宽 + NX, 绘区.Y0 + 高差_ + NX), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.XM - 水差__, 绘区.XM - 水差_, 绘区.Y0 + 高差_ - 线宽 + NX, 绘区.Y0 + 高差_ + NX), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.X0 + 水差_, 绘区.X0 + 水差__, 绘区.YM - 高差_ - 线宽 - NX, 绘区.YM - 高差_ - NX), 基色, 0);
                    图.图案(方图1, 边界框.创建(绘区.XM - 水差__, 绘区.XM - 水差_, 绘区.YM - 高差_ - 线宽 - NX, 绘区.YM - 高差_ - NX), 基色, 0);
                    边界框
                        速度框 = 边界框.创建(绘区.X0, 绘区.X0 + 水差_ - NX * 0.05f, (绘区.Y0 + 绘区.YM) * 0.5f - NX_H, (绘区.Y0 + 绘区.YM) * 0.5f + NX_H),
                        海拔框 = 边界框.创建(绘区.XM - 速度框.a, 绘区.XM, 速度框.Y0, 速度框.YM);
                    图.框框(方图1, 速度框, 基色, 背景, 线宽 * 2, 0);
                    图.框框(方图1, 海拔框, 基色, 背景, 线宽 * 2, 0);
                    自适应文本(图, 速度框 * 0.9f, $"{速率转文本(物理.飞船速度, 0)}", 基色, TextAlignment.CENTER, null, true);
                    自适应文本(图, 速度框 * 0.9f - 向量(0, NX_HO), "速度", 基色, TextAlignment.CENTER, null, true);
                    if (物理.海拔高度.HasValue)
                        自适应文本(图, 海拔框 * 0.9f, $"{距离转文本(物理.海拔高度.Value, 0)}", 基色, TextAlignment.CENTER, null, true);
                    else
                        自适应文本(图, 海拔框 * 0.9f, "低引力区", 基色, TextAlignment.CENTER, null, true);
                    自适应文本(图, 海拔框 * 0.9f - 向量(0, NX_HO), "海拔", 基色, TextAlignment.CENTER, null, true);
                }
                图.图案("AH_BoreSight", 位置 + 向量(0f, 32f), 向量(_缩放 * 50), 基色, -(MathHelper.Pi) / 2f);
                if (Vector3.Dot(V, 矩阵.Forward) >= -0.1f)
                {
                    Vector3 法线 = Vector3.Reject(V, 矩阵.Forward);
                    法线 = Vector3.TransformNormal(法线, MatrixD.Invert(矩阵));
                    图.图案("AH_VelocityVector", 位置 + Vector2.ClampToSphere(向量(法线.X, -法线.Y) * 尺寸 / 参考尺寸, 半径), 向量(50f) * _缩放, 基色);
                }
            }
            public static float 计算字符串宽度(string 内容) { float 长度 = 0; foreach (var 符 in 内容) { if (符 == '1' || 符 == '-') 长度 += 8; else if (符 == '0' || (符 > '1' && 符 <= '9') || (符 >= 'a' && 符 <= 'z') || 符 == '>' || 符 == '<' || (符 >= 'A' && 符 <= 'Z')) 长度 += 18; else 长度 += 28; } return 长度; }
            public static Color 派系颜色(My图标显示参数 目标) { Color 颜色; switch (目标.派系) { case 1: 颜色 = 自己; break; case 2: 颜色 = 敌人; break; case 3: 颜色 = 友军; break; default: 颜色 = 未知; break; } return 颜色; }
            public static float 角度计算(Vector2 向量) { if (Vector2.IsZero(ref 向量)) return 0; float 结果 = (float)置零(Math.Acos(向量.X / 向量.Length())); if (向量.Y < 0) 结果 = MathHelper.WrapAngle(MathHelper.TwoPi - 结果); return 结果; }
            public static void 自适应文本(雪碧列表 图, 边界框 绘区, string 内容, Color 基色, TextAlignment 对齐 = 雪碧列表.默认对齐, float? 字体尺寸_重载 = null, bool 自长 = false)
            {
                if (内容 == "") return;
                string[] 文行 = 内容.Split(new char[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
                if (文行 == null || 文行.Length < 1) return;
                float 最长 = 0;
                for (int 引 = 0; 引 < 文行.Length; 引++)
                    最长 = Math.Max(最长, 计算字符串宽度(文行[引]));
                float 高段 = 绘区.最小边长 / 文行.Length,
                    缩放 = ((!自长) ? (绘区.b / (字体尺寸 * 文行.Length)) : V最小值(绘区.尺寸 / 向量(最长, 字体尺寸 * 文行.Length))) * (字体尺寸_重载 ?? 1),
                    字寸 = 字体尺寸 * 缩放,
                    垂偏 = (高段 - 字寸) * 0.5f;
                Vector2 起始 = 向量((对齐 == TextAlignment.LEFT) ? 绘区.X0 : (对齐 == TextAlignment.RIGHT) ? 绘区.XM : (绘区.X0 + 绘区.XM) * 0.5f, 绘区.Y0);
                for (int 引 = 0; 引 < 文行.Length; 引++)
                    图.文本(文行[引], 起始 + 向量(0, 引 * 高段 + 垂偏), 基色, "White", 对齐, 缩放);
            }
            public static void 文本参数(雪碧列表 图, 边界框 绘区, string 内容, TextAlignment 对齐, float 线宽, Color 基色, Color 背景, float? 字体尺寸_重载 = null, bool 自适应长 = false)
            {
                float 缩进线宽 = 线宽 * 2;
                线框和裁切(图, 绘区, 基色, 背景, 缩进线宽, true, true);
                自适应文本(图, 边界框.创建_中心_尺寸(绘区.中心, 绘区.尺寸 - 向量(绘区.最小边长 * 内部距离)), 内容, 基色, 对齐, 字体尺寸_重载, 自适应长);
            }
            public static void 设备百分条(雪碧列表 图, 边界框 绘区, string 名称, float 百分比, float 线宽, Color 基色, Color 背景, float? 字体尺寸_重载 = null)
            {
                百分比 = MathHelper.Clamp(百分比, 0, 1);
                float 缩进线宽 = 线宽 * 2;
                线框和裁切(图, 绘区, 基色, 背景, 缩进线宽, true, true);
                float 尺寸 = 绘区.最小边长, 文体 = (尺寸 / 字体尺寸) * (字体尺寸_重载 ?? 1) * 0.75f, 文尺 = 文体 * 32, 垂偏 = -文尺 * 0.5f;
                边界框 区 = 边界框.创建_中心_尺寸(绘区.中心, 绘区.尺寸 - 向量(尺寸 * 内部距离)), 文区, 百框;
                float 文长 = 4f * 文尺;
                if (文长 > 区.半尺寸.X) { 文体 *= 0.5f; 文尺 = 文体 * 32; 垂偏 = -文尺 * 0.5f; 文区 = 边界框.创建(区.X0, 区.XM, 区.Y0, 区.Y0 + 区.半尺寸.Y); 百框 = 边界框.创建(区.X0, 区.XM, 文区.YM, 区.YM); }
                else { 文区 = 边界框.创建(区.X0, 区.X0 + 文长, 区.Y0, 区.YM); 百框 = 边界框.创建(文区.XM, 区.XM, 区.Y0, 区.YM); }
                图.文本(名称, 向量(文区.中心.X, 文区.Y0 + (文区.b - 文尺) * 0.5f), Color.White, "White", TextAlignment.CENTER, 文体);
                图.进度条(百分比, 百框, 基色, 背景, Color.Lerp(Color.OrangeRed, Color.MediumPurple, 百分比), 缩进线宽);
            }
            public static readonly float 步进角度 = 2.5f, 视场总角度 = MathHelper.ToRadians(10), 步进角度_弧度 = MathHelper.ToRadians(步进角度), 视场半角度 = 视场总角度 * 0.5f, 雷达显示占比 = 0.9f;

            public static readonly int 刻度总数量 = (int)(视场总角度 / 步进角度_弧度), 俯仰角数量 = ((刻度总数量 % 2 != 0) ? ((刻度总数量 - 1) / 2) : (刻度总数量 / 2)) + 3;
        }
    }
}
